
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">C:\Users\Michael\go\pixelArtVectorizer\ambig.go (75.0%)</option>
				
				<option value="file1">C:\Users\Michael\go\pixelArtVectorizer\file.go (77.8%)</option>
				
				<option value="file2">C:\Users\Michael\go\pixelArtVectorizer\genGraph.go (98.0%)</option>
				
				<option value="file3">C:\Users\Michael\go\pixelArtVectorizer\graph.go (78.8%)</option>
				
				<option value="file4">C:\Users\Michael\go\pixelArtVectorizer\main.go (50.0%)</option>
				
				<option value="file5">C:\Users\Michael\go\pixelArtVectorizer\pixel.go (100.0%)</option>
				
				<option value="file6">C:\Users\Michael\go\pixelArtVectorizer\reshape.go (100.0%)</option>
				
				<option value="file7">C:\Users\Michael\go\pixelArtVectorizer\svg.go (97.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

// solveAmbiguities
// analyse block of 2x2 vertex to delete the max amount of edges and alse remover cross conections between this vertexes/pixels
// 00 10
// 01 11
func solveAmbiguities(pixels [][]Pixel, g *Graph, genSVG bool) <span class="cov8" title="1">{

        width := len(pixels)
        height := len(pixels[0])

        //Pixel being analysed
        p00, p10 := Pixel{}, Pixel{}
        p01, p11 := Pixel{}, Pixel{}

        for x := 0; x &lt; width; x++ </span><span class="cov8" title="1">{
                for y := 0; y &lt; height; y++ </span><span class="cov8" title="1">{
                        p00 = getPixel(pixels, x, y)
                        p10 = getPixel(pixels, x+1, y)
                        p01 = getPixel(pixels, x, y+1)
                        p11 = getPixel(pixels, x+1, y+1)

                        //Crossing edges that we need to elimenate
                        if g.Edge(p11.V, p00.V) &amp;&amp; g.Edge(p01.V, p10.V) </span><span class="cov8" title="1">{
                                // Ambiguity
                                if p00.Color == p01.Color &amp;&amp; p00.Color != (Color{}) </span><span class="cov8" title="1">{ //Same color and not empty pixel
                                        if g.Edge(p11.V, p00.V) </span><span class="cov8" title="1">{
                                                g.DeleteBoth(p11.V, p00.V)
                                        }</span>
                                        <span class="cov8" title="1">if g.Edge(p01.V, p10.V) </span><span class="cov8" title="1">{
                                                g.DeleteBoth(p01.V, p10.V)
                                        }</span>

                                        // island heuristic
                                } else<span class="cov8" title="1"> if g.Degree(p11.V) == 1 || g.Degree(p00.V) == 1 </span><span class="cov8" title="1">{ //if is alone need to keep connected
                                        if g.Edge(p01.V, p10.V) </span><span class="cov8" title="1">{
                                                g.DeleteBoth(p01.V, p10.V)
                                        }</span>
                                } else<span class="cov8" title="1"> if g.Degree(p01.V) == 1 || g.Degree(p10.V) == 1 </span><span class="cov8" title="1">{
                                        if g.Edge(p11.V, p00.V) </span><span class="cov8" title="1">{
                                                g.DeleteBoth(p11.V, p00.V)
                                        }</span>
                                } else<span class="cov8" title="1"> {

                                        // curve heuristic
                                        if g.Degree(p01.V) == 2 || g.Degree(p10.V) == 2 || g.Degree(p11.V) == 2 || g.Degree(p00.V) == 2 </span><span class="cov8" title="1">{ // is part of a curve the bigger curve is keep connected
                                                if curveSize(*g, p01.V, p10.V) &lt;= curveSize(*g, p11.V, p00.V) </span><span class="cov8" title="1">{
                                                        g.DeleteBoth(p01.V, p10.V)
                                                }</span> else<span class="cov8" title="1"> {
                                                        g.DeleteBoth(p11.V, p00.V)
                                                }</span>
                                        } else<span class="cov0" title="0"> {

                                                //heuristic of overlapping pixels
                                                sumC1 := 0
                                                sumC2 := 0
                                                //start x and y with -4 positions to check 3 pixels in both ways
                                                xs := x - 4
                                                ys := y - 4
                                                c1 := p00.Color
                                                c2 := p01.Color

                                                for xs &lt;= x+3 </span><span class="cov0" title="0">{
                                                        for ys &lt;= y+3 </span><span class="cov0" title="0">{
                                                                if p00.Color == c1 </span><span class="cov0" title="0">{
                                                                        sumC1++
                                                                }</span> else<span class="cov0" title="0"> if p00.Color == c2 </span><span class="cov0" title="0">{
                                                                        sumC2++
                                                                }</span>
                                                                <span class="cov0" title="0">ys++</span>
                                                        }
                                                        <span class="cov0" title="0">xs++</span>
                                                }
                                                //the color in largest amount represents the background and should be kept connected
                                                <span class="cov0" title="0">if sumC1 &gt; sumC2 </span><span class="cov0" title="0">{
                                                        g.DeleteBoth(p11.V, p00.V)
                                                }</span> else<span class="cov0" title="0"> {
                                                        g.DeleteBoth(p01.V, p10.V)
                                                }</span>
                                        }

                                }
                        }
                }
        }
        <span class="cov8" title="1">if genSVG </span><span class="cov8" title="1">{
                generateSVG(pixels, g, SvgConfig{"./results/2.solveAmbiguities", 50, true, true, true, false})
        }</span>

}

//curveSize return the size of the 1 pixel line
func curveSize(g Graph, verticeA int, verticeB int) int <span class="cov8" title="1">{
        size := 0
        hasEdge := true
        if g.Degree(verticeA) == 2 || g.Degree(verticeB) == 2 </span><span class="cov8" title="1">{
                size++
                for hasEdge </span><span class="cov8" title="1">{

                        hasEdge = false
                        if g.Degree(verticeA) == 2 </span><span class="cov8" title="1">{
                                size++

                                g.Visit(verticeA, func(w int) (skip bool) </span><span class="cov8" title="1">{
                                        if w == verticeA || w == verticeB </span><span class="cov8" title="1">{
                                                skip = true // Aborts the call to Visit.
                                        }</span>
                                        <span class="cov8" title="1">verticeA = w
                                        hasEdge = true
                                        return</span>
                                })

                        }

                        <span class="cov8" title="1">if g.Degree(verticeB) == 2 </span><span class="cov8" title="1">{
                                size++

                                g.Visit(verticeB, func(w int) (skip bool) </span><span class="cov8" title="1">{
                                        if w == verticeB || w == verticeA </span><span class="cov8" title="1">{
                                                skip = true // Aborts the call to Visit.
                                        }</span>
                                        <span class="cov8" title="1">verticeB = w
                                        hasEdge = true
                                        return</span>
                                })

                        }
                }
        }
        <span class="cov8" title="1">return size</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "image"
        "image/png"
        "os"
)

func readImage(file string) (image.Image, error) <span class="cov8" title="1">{
        // Read image from file that already exists
        existingImageFile, err := os.Open(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer existingImageFile.Close()

        // Calling the generic image.Decode() will tell give us the data
        // and type of image it is as a string. We expect "png"
        /*imageData, imageType, err := image.Decode(existingImageFile)
        if err != nil {
                return nil, err
        }

        fmt.Println(imageData)
        fmt.Println(imageType)*/

        // We only need this because we already read from the file
        // We have to reset the file pointer back to beginning
        existingImageFile.Seek(0, 0)

        // Alternatively, since we know it is a png already
        // we can call png.Decode() directly
        loadedImage, err := png.Decode(existingImageFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        //fmt.Println(loadedImage)
        <span class="cov8" title="1">return loadedImage, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

//newGraph generate a graph from pixel art with connections
//mario_8bit.png example
//        Dimensions 19 x 18
//        width 19
//        height 18
func genGraph(pixels [][]Pixel, genSVG bool) Graph <span class="cov8" title="1">{

        width := len(pixels)
        height := len(pixels[0])

        g := NewGraph()
        xc := 0
        yc := 0
        p := Pixel{}
        pc := p //Comparison pixel

        //Add vertex for all pixels
        for x := 0; x &lt; width; x++ </span><span class="cov8" title="1">{
                for y := 0; y &lt; height; y++ </span><span class="cov8" title="1">{
                        g.AddVertex()
                }</span>
        }

        <span class="cov8" title="1">for x := 0; x &lt; width; x++ </span><span class="cov8" title="1">{
                for y := 0; y &lt; height; y++ </span><span class="cov8" title="1">{

                        p = pixels[x][y]

                        xc = x - 1

                        yc = y - 1
                        pc = getPixel(pixels, xc, yc)
                        if p.Color == pc.Color </span><span class="cov8" title="1">{
                                g.AddBoth(p.V, pc.V, p.Color)
                        }</span>

                        <span class="cov8" title="1">xc = x
                        yc = y - 1
                        pc = getPixel(pixels, xc, yc)
                        if p.Color == pc.Color </span><span class="cov8" title="1">{
                                g.AddBoth(p.V, pc.V, p.Color)
                        }</span>

                        <span class="cov8" title="1">xc = x + 1
                        yc = y - 1
                        pc = getPixel(pixels, xc, yc)
                        if p.Color == pc.Color </span><span class="cov8" title="1">{
                                g.AddBoth(p.V, pc.V, p.Color)

                        }</span>
                        <span class="cov8" title="1">xc = x - 1
                        yc = y

                        pc = getPixel(pixels, xc, yc)
                        if p.Color == pc.Color </span><span class="cov8" title="1">{
                                g.AddBoth(p.V, pc.V, p.Color)
                        }</span>
                }
        }
        <span class="cov8" title="1">if genSVG </span><span class="cov8" title="1">{

                generateSVG(pixels, g, SvgConfig{"./results/0.source", 50, true, false, false, false})
                generateSVG(pixels, g, SvgConfig{"./results/1.genGraph", 50, true, true, true, false})
        }</span>
        <span class="cov8" title="1">return *g</span>

}

func getPixel(pixels [][]Pixel, x int, y int) Pixel <span class="cov8" title="1">{
        width := len(pixels)
        height := len(pixels[0])

        if x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; width &amp;&amp; y &lt; height </span><span class="cov8" title="1">{
                return pixels[x][y]
        }</span>
        <span class="cov8" title="1">return Pixel{V: -1}</span>

}

//getpixelv from Vertice index
func getPixelV(pixels [][]Pixel, v int) Pixel <span class="cov8" title="1">{
        width := len(pixels)
        height := len(pixels[0])
        p := Pixel{}
        for x := 0; x &lt; width; x++ </span><span class="cov8" title="1">{
                for y := 0; y &lt; height; y++ </span><span class="cov8" title="1">{
                        p = getPixel(pixels, x, y)
                        if p.V == v </span><span class="cov8" title="1">{
                                return p
                        }</span>
                }
        }
        <span class="cov0" title="0">return p</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "strconv"
)

const initialMapSize = 4

// Graph with pixel information
type Graph struct {
        edges map[int]map[int]Color
}

// NewGraph constructs a new graph
func NewGraph() *Graph <span class="cov8" title="1">{
        //return &amp;Graph{edges: make([]map[int]Color, n)}
        return &amp;Graph{edges: make(map[int]map[int]Color)}
}</span>

// Order returns the number of vertices in the graph.
func (g *Graph) Order() int <span class="cov8" title="1">{
        return len(g.edges)
}</span>

// Edge tells if there is an edge from v to w.
func (g *Graph) Edge(v, w int) bool <span class="cov8" title="1">{
        if v &lt; 0 || v &gt;= g.Order() </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if w &lt; 0 || w &gt;= g.Order() </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">_, ok := g.edges[v][w]

        return ok</span>
}

// AddVertex and return its index
func (g *Graph) AddVertex() int <span class="cov8" title="1">{
        v := len(g.edges)
        g.edges[v] = make(map[int]Color)
        return v
}</span>

// Add inserts a directed edge from v to w with zero cost.
// It removes the previous cost if this edge already exists.
func (g *Graph) Add(v, w int) <span class="cov0" title="0">{
        g.AddCost(v, w, Color{})
}</span>

// AddCost inserts a directed edge from v to w with cost c.
// It overwrites the previous cost if this edge already exists.
func (g *Graph) AddCost(v, w int, c Color) <span class="cov8" title="1">{
        // Make sure not to break internal state.
        if w &lt; 0 || w &gt;= len(g.edges) </span><span class="cov0" title="0">{
                panic("vertex out of range: " + strconv.Itoa(w))</span>
        }
        <span class="cov8" title="1">if g.edges[v] == nil </span><span class="cov0" title="0">{
                g.edges[v] = make(map[int]Color, initialMapSize)
        }</span>
        <span class="cov8" title="1">g.edges[v][w] = c</span>
}

// AddBoth inserts edges with zero cost between v and w.
// It removes the previous costs if these edges already exist.
func (g *Graph) AddBoth(v, w int, c Color) <span class="cov8" title="1">{
        g.AddCost(v, w, c)
        if v != w </span><span class="cov8" title="1">{
                g.AddCost(w, v, c)
        }</span>
}

// Delete removes an edge from v to w.
func (g *Graph) Delete(v, w int) <span class="cov8" title="1">{
        delete(g.edges[v], w)
}</span>

// DeleteBoth removes all edges between v and w.
func (g *Graph) DeleteBoth(v, w int) <span class="cov8" title="1">{
        g.Delete(v, w)
        if v != w </span><span class="cov8" title="1">{
                g.Delete(w, v)
        }</span>
}

// Degree returns the number of outward directed edges from v.
func (g *Graph) Degree(v int) int <span class="cov8" title="1">{
        return len(g.edges[v])
}</span>

// VisitColor calls the do function for each neighbor w of v,
// with c equal to the cost of the edge from v to w.
// The neighbors are visited in increasing numerical order.
// If do returns true, Visit returns immediately,
// skipping any remaining neighbors, and returns true.
func (g *Graph) VisitColor(v int, do func(w int, c Color) bool) bool <span class="cov0" title="0">{
        for w, c := range g.edges[v] </span><span class="cov0" title="0">{
                if do(w, c) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Visit calls the do function for each neighbor w of v,
func (g *Graph) Visit(v int, do func(w int) bool) bool <span class="cov8" title="1">{
        for w := range g.edges[v] </span><span class="cov8" title="1">{
                if do(w) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "fmt"
        "os"
)

func main() <span class="cov0" title="0">{
        imagePath := os.Args[1]
        vectorize(imagePath)
}</span>

//vectorize
func vectorize(imagePath string) <span class="cov8" title="1">{
        if len(imagePath) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No image parameter received")
                return
        }</span>
        <span class="cov8" title="1">img, err := readImage(imagePath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error reading image", err)
                return
        }</span>

        <span class="cov8" title="1">pixels, err := getPixels(img)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error converting to bi-dimensional array", err)
                return
        }</span>
        //bi-dimensional pixel array
        <span class="cov8" title="1">g := genGraph(pixels, true)

        solveAmbiguities(pixels, &amp;g, true)
        reshape(pixels, &amp;g, true)</span>
        // drawNewGraphEdges()
        // createNewCurves()
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "fmt"
        "image"
)

// Pixel struct
type Pixel struct {
        V      int // index in graph
        Color  Color
        X      int
        Y      int
        Points []Point
}

//Point struct
type Point struct {
        X int
        Y int
}

// Color of Pixel
type Color struct {
        R int
        G int
        B int
        A int
}

// hexColor returns an HTML hex-representation of c. The alpha channel is dropped
// and precision is truncated to 8 bits per channel
func (c Color) hexColor() string <span class="cov8" title="1">{
        return fmt.Sprintf("#%.2x%.2x%.2x", c.R, c.G, c.B)
}</span>

// Get the bi-dimensional pixel array
func getPixels(img image.Image) ([][]Pixel, error) <span class="cov8" title="1">{
        bounds := img.Bounds()
        width, height := bounds.Max.X, bounds.Max.Y

        var pixels [][]Pixel
        vCount := 0
        for x := 0; x &lt; width; x++ </span><span class="cov8" title="1">{
                var col []Pixel
                for y := 0; y &lt; height; y++ </span><span class="cov8" title="1">{
                        col = append(col, Pixel{vCount, rgbaToColor(img.At(x, y).RGBA()), x, y, []Point{}})
                        vCount++
                }</span>
                <span class="cov8" title="1">pixels = append(pixels, col)</span>
        }

        <span class="cov8" title="1">return pixels, nil</span>
}

// img.At(x, y).RGBA() returns four uint32 values; we want a Pixel
func rgbaToColor(r uint32, g uint32, b uint32, a uint32) Color <span class="cov8" title="1">{
        return Color{int(r / 257), int(g / 257), int(b / 257), int(a / 257)}
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

//reshape all the pixel in the original PixelArt
//here we analyse every pixel checking the connections around it in a 3x3 window around it
func reshape(pixels [][]Pixel, g *Graph, genSVG bool) <span class="cov8" title="1">{
        scale := 7

        //Visit all Vertices
        for v := 0; v &lt; g.Order(); v++ </span><span class="cov8" title="1">{
                //Top Left of new pixel
                /*
                        if has edge to tl
                           -2 +2
                           +2 -2
                        if the top has edge to bl
                                +2 +2
                        else
                                0 0
                */
                x := getPixelV(pixels, v).X
                y := getPixelV(pixels, v).Y
                p := getPixel(pixels, x, y)

                tl := getPixel(pixels, x-1, y-1)
                t := getPixel(pixels, x, y-1)
                tr := getPixel(pixels, x+1, y-1)

                l := getPixel(pixels, x-1, y)
                r := getPixel(pixels, x+1, y)

                br := getPixel(pixels, x+1, y+1)
                b := getPixel(pixels, x, y+1)
                bl := getPixel(pixels, x-1, y+1)

                //Edge between center pixel and top left
                if g.Edge(p.V, tl.V) </span><span class="cov8" title="1">{
                        pixels[x][y].Points = append(pixels[x][y].Points, Point{x*scale - 2, y*scale + 2})
                        pixels[x][y].Points = append(pixels[x][y].Points, Point{x*scale + 2, y*scale - 2})
                }</span> else<span class="cov8" title="1"> if g.Edge(t.V, l.V) </span><span class="cov8" title="1">{ //Edge between the top pixel and the left
                        pixels[x][y].Points = append(pixels[x][y].Points, Point{x*scale + 2, y*scale + 2})
                }</span> else<span class="cov8" title="1"> {
                        pixels[x][y].Points = append(pixels[x][y].Points, Point{x*scale + 0, y*scale + 0})
                }</span>

                //Top Right of new pixel
                /*
                        if has edge to tr
                                +5 -2
                                +9 +2
                        if the top has edge br
                                +5  +2
                        else
                                +7  +0
                */
                <span class="cov8" title="1">if g.Edge(p.V, tr.V) </span><span class="cov8" title="1">{ //Edge between center pixel and top right
                        pixels[x][y].Points = append(pixels[x][y].Points, Point{x*scale + 5, y*scale - 2})
                        pixels[x][y].Points = append(pixels[x][y].Points, Point{x*scale + 9, y*scale + 2})
                }</span> else<span class="cov8" title="1"> if g.Edge(t.V, r.V) </span><span class="cov8" title="1">{ //Edge between top pixel and  pixel in the right
                        pixels[x][y].Points = append(pixels[x][y].Points, Point{x*scale + 5, y*scale + 2})
                }</span> else<span class="cov8" title="1"> {
                        pixels[x][y].Points = append(pixels[x][y].Points, Point{x*scale + 7, y*scale + 0})
                }</span>

                //Botton Right of new pixel
                /*
                        if has edge to br
                                  +9 +5
                                  +5 +9
                        if the top has edge to tr
                                  +5  +5
                        else
                                  +7  +7
                */
                <span class="cov8" title="1">if g.Edge(p.V, br.V) </span><span class="cov8" title="1">{ //Edge between center pixel and botton right
                        pixels[x][y].Points = append(pixels[x][y].Points, Point{x*scale + 9, y*scale + 5})
                        pixels[x][y].Points = append(pixels[x][y].Points, Point{x*scale + 5, y*scale + 9})
                }</span> else<span class="cov8" title="1"> if g.Edge(b.V, r.V) </span><span class="cov8" title="1">{ //Edge between botton pixel and the pixel to the righ
                        pixels[x][y].Points = append(pixels[x][y].Points, Point{x*scale + 5, y*scale + 5})
                }</span> else<span class="cov8" title="1"> {
                        pixels[x][y].Points = append(pixels[x][y].Points, Point{x*scale + 7, y*scale + 7})
                }</span>

                //Botton Left of new pixel
                /*
                        if has edge to bl
                                   +2 +9
                                   -2 +5
                        if the top has edge to tl
                                   +2 +5
                        else
                                   +0 +7
                */
                <span class="cov8" title="1">if g.Edge(p.V, bl.V) </span><span class="cov8" title="1">{ //Edge between center pixel and botton left
                        pixels[x][y].Points = append(pixels[x][y].Points, Point{x*scale + 2, y*scale + 9})
                        pixels[x][y].Points = append(pixels[x][y].Points, Point{x*scale - 2, y*scale + 5})
                }</span> else<span class="cov8" title="1"> if g.Edge(b.V, l.V) </span><span class="cov8" title="1">{ //Edge between below pixel and botton pixel
                        pixels[x][y].Points = append(pixels[x][y].Points, Point{x*scale + 2, y*scale + 5})
                }</span> else<span class="cov8" title="1"> {
                        pixels[x][y].Points = append(pixels[x][y].Points, Point{x*scale + 0, y*scale + 7})
                }</span>

        }
        <span class="cov8" title="1">if genSVG </span><span class="cov8" title="1">{
                generateSVG(pixels, g, SvgConfig{"./results/3.pixelReshape", 7, false, false, false, true})
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "os"

        svg "github.com/ajstarks/svgo"
)

// SvgConfig configurations to SVG file
type SvgConfig struct {
        fileName     string
        scale        int
        withPixel    bool
        withVertices bool
        withEdges    bool
        withPoints   bool
}

func generateSVG(pixels [][]Pixel, g *Graph, config SvgConfig) <span class="cov8" title="1">{
        scale := config.scale
        height := len(pixels)
        width := len(pixels[0])

        f, _ := os.Create(config.fileName + ".svg")
        canvas := svg.New(f)
        p := pixels[0][0]
        canvas.Start(height*scale, width*scale)

        //Print all pixels squares
        if config.withPixel </span><span class="cov8" title="1">{
                for y := 0; y &lt; width; y++ </span><span class="cov8" title="1">{
                        for x := 0; x &lt; height; x++ </span><span class="cov8" title="1">{
                                p = pixels[x][y]
                                canvas.Rect(x*scale, y*scale, scale, scale,
                                        "fill=\""+p.Color.hexColor()+"\" stroke=\"Black\" stroke-width=\"1\"")
                        }</span>
                }
        }

        //Print all Vertex center points
        <span class="cov8" title="1">if config.withVertices </span><span class="cov8" title="1">{
                r := scale / 10 //radius
                if scale &lt; 10 </span><span class="cov0" title="0">{
                        r = 1
                }</span>

                <span class="cov8" title="1">for y := 0; y &lt; width; y++ </span><span class="cov8" title="1">{
                        for x := 0; x &lt; height; x++ </span><span class="cov8" title="1">{
                                p = pixels[x][y]
                                canvas.Circle(x*scale+scale/2, y*scale+scale/2, r,
                                        "fill=\"blue\" stroke=\"Black\" stroke-width=\"1\"")
                        }</span>
                }
        }

        <span class="cov8" title="1">if config.withPoints </span><span class="cov8" title="1">{

                for y := 0; y &lt; width; y++ </span><span class="cov8" title="1">{
                        for x := 0; x &lt; height; x++ </span><span class="cov8" title="1">{
                                p = pixels[x][y]
                                var sX []int
                                var sY []int
                                for z := 0; z &lt; len(p.Points); z++ </span><span class="cov8" title="1">{
                                        sX = append(sX, p.Points[z].X)
                                        sY = append(sY, p.Points[z].Y)
                                }</span>
                                <span class="cov8" title="1">if len(sX) &gt; 0 </span><span class="cov8" title="1">{
                                        canvas.Polygon(sX, sY,
                                                "fill=\""+p.Color.hexColor()+"\" stroke=\"Black\" stroke-width=\"0.2\"")
                                }</span>
                        }
                }
        }

        //Print all edges lines
        <span class="cov8" title="1">if config.withEdges </span><span class="cov8" title="1">{
                p1 := Pixel{}
                p2 := Pixel{}
                for v := 0; v &lt; g.Order(); v++ </span><span class="cov8" title="1">{
                        g.Visit(v, func(w int) (skip bool) </span><span class="cov8" title="1">{
                                p1 = getPixelV(pixels, v)
                                p2 = getPixelV(pixels, w)
                                canvas.Line(p1.X*scale+scale/2, p1.Y*scale+scale/2,
                                        p2.X*scale+scale/2, p2.Y*scale+scale/2,
                                        "stroke=\"Blue\"", "stroke-width=\"0.8\"")
                                return
                        }</span>)

                }
        }
        <span class="cov8" title="1">canvas.End()
        f.Close()</span>

}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
